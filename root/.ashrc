# ~/.ashrc

# ensure root doesn't leak information
# when creating file/dir, however this may be problematic
# with package manager that follows the mask...
umask 027

# edit and reload ashrc.
ashrc()
{
  vi ~/.ashrc
  . ~/.ashrc
}

# permit to install content inside /usr/local from user privilege.
fs.open.usr.local()
{
  chmod -v o+rwx /usr/local/lib
  chmod -v o+rwx /usr/local/bin
  chmod -v o+rwx /usr/local/sbin
  chmod -v o+rwx /usr/local/include
  chmod -v o+rwx /usr/local/share
}

# permit to install content inside /opt from user privilege.
fs.open.opt()
{
  chmod -v o+rwx /opt
}

# clean up write access and reset owner to root.
fs.close()
{
  if [ -d "$1" ]; then
    chmod -Rv o-w "$1"
    chown -Rv root:root "$1"
  else
    echo "$0 <dir>\n\t- The directory to reset privileges."
  fi
}

# little words :) Really with this 3 functions we can craft dynamic routing :D
# .1 because you route to your trusty dns first...
# .2 because you have to req an host before going out...
# .3 a domain name translate to IP and an IP is the identifier your routing table needs.
# .4 WHERE IS MY PHD?

# close network entry at the routing lvl and open route access to a particular host.
route.close.wan()
{
  local GATEWAY="$1"
  local TRUSTEDHOST="$2"
  local INTERFACE="$3"
  ip route add "$GATEWAY" dev "$INTERFACE"  metric 1 onlink
  ip route del default
  ip route add default blackhole dev "$INTERFACE"
}

route.open.to.via()
{
  local GATEWAY="$1"
  local TRUSTEDHOST="$2"
  local INTERFACE="$3"
  ip route del default
  ip route add "$TRUSTEDHOST" via "$GATEWAY" dev "$INTERFACE"  metric 1 onlink
  ip route add default blackhole dev "$INTERFACE"
}

# open network entry at the routing lvl to the wide area network
route.open.wan()
{
  local GATEWAY="$1"
  local TRUSTEDHOST="$2"
  local INTERFACE="$3"
  ip route del default
  ip route add default via "$GATEWAY" dev "$INTERFACE"  metric 1 onlink
}
